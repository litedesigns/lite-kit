{"version":3,"sources":["../src/index.ts","../src/accordion/Accordion.tsx","../src/utils/cn.ts","../src/accordion/useScrollDetection.ts"],"sourcesContent":["// Accordion\nexport { Accordion } from './accordion/Accordion';\nexport { useScrollDetection } from './accordion/useScrollDetection';\nexport type {\n  AccordionProps,\n  AccordionItem,\n  ScrollConfig,\n} from './accordion/types';\n\n// Utilities\nexport { cn } from './utils/cn';\n","'use client';\n\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport { cn } from '../utils/cn';\nimport { useScrollDetection } from './useScrollDetection';\nimport type { AccordionProps, AccordionItem } from './types';\n\n// Chevron icon component (inline to avoid external dependency)\nfunction ChevronIcon({ className, isOpen }: { className?: string; isOpen: boolean }) {\n  return (\n    <svg\n      className={cn(\n        'lite-kit-accordion-chevron w-4 h-4 flex-shrink-0 transition-transform duration-300',\n        isOpen && 'lite-kit-accordion-chevron--open rotate-180',\n        className\n      )}\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <polyline points=\"6 9 12 15 18 9\" />\n    </svg>\n  );\n}\n\nexport function Accordion({\n  items,\n  mode = 'single',\n  defaultOpen,\n  collapsible = true,\n  scrollDetect = false,\n  scrollConfig,\n  className,\n  itemClassName,\n  onValueChange,\n}: AccordionProps) {\n  // Initialise open state\n  const getInitialOpenIds = (): string[] => {\n    if (!defaultOpen) return [];\n    if (Array.isArray(defaultOpen)) return defaultOpen;\n    return [defaultOpen];\n  };\n\n  const [openIds, setOpenIds] = useState<string[]>(getInitialOpenIds);\n  const itemRefs = useRef<(HTMLDivElement | null)[]>([]);\n  const [manuallyClosedId, setManuallyClosedId] = useState<string | null>(null);\n\n  // Convert index to id for scroll detection\n  const activeIndex = openIds.length > 0\n    ? items.findIndex(item => item.id === openIds[0])\n    : null;\n\n  // Scroll detection hook\n  const {\n    handleManualInteraction,\n    isManuallySelected,\n    manuallyClosedIndex,\n    clearManuallyClosed,\n  } = useScrollDetection({\n    itemRefs,\n    itemCount: items.length,\n    enabled: scrollDetect,\n    config: scrollConfig,\n    activeIndex,\n    onActiveChange: (index) => {\n      if (index !== null) {\n        const newId = items[index]?.id;\n        if (newId && newId !== manuallyClosedId) {\n          setOpenIds([newId]);\n          onValueChange?.([newId]);\n        }\n      }\n    },\n  });\n\n  // Handle item toggle\n  const handleToggle = useCallback((item: AccordionItem, index: number) => {\n    const isOpen = openIds.includes(item.id);\n\n    if (scrollDetect) {\n      handleManualInteraction(index);\n    }\n\n    if (isOpen) {\n      // Closing\n      if (collapsible || openIds.length > 1) {\n        if (scrollDetect) {\n          setManuallyClosedId(item.id);\n        }\n        const newIds = openIds.filter(id => id !== item.id);\n        setOpenIds(newIds);\n        onValueChange?.(newIds);\n      }\n    } else {\n      // Opening\n      setManuallyClosedId(null);\n      clearManuallyClosed();\n\n      if (mode === 'single') {\n        setOpenIds([item.id]);\n        onValueChange?.([item.id]);\n      } else {\n        const newIds = [...openIds, item.id];\n        setOpenIds(newIds);\n        onValueChange?.(newIds);\n      }\n    }\n  }, [openIds, mode, collapsible, scrollDetect, handleManualInteraction, clearManuallyClosed, onValueChange]);\n\n  // Clear manually closed state when scrolling away\n  useEffect(() => {\n    if (manuallyClosedIndex !== null) {\n      const closedId = items[manuallyClosedIndex]?.id;\n      if (closedId !== manuallyClosedId) {\n        setManuallyClosedId(null);\n      }\n    }\n  }, [manuallyClosedIndex, items, manuallyClosedId]);\n\n  return (\n    <div className={cn('lite-kit-accordion space-y-2', className)}>\n      {items.map((item, index) => {\n        const isOpen = openIds.includes(item.id);\n        const Icon = item.icon;\n\n        return (\n          <div\n            key={item.id}\n            ref={(el) => { itemRefs.current[index] = el; }}\n            className={cn(\n              'lite-kit-accordion-item overflow-hidden transition-all duration-300 ease-out',\n              isOpen && 'lite-kit-accordion-item--open',\n              itemClassName\n            )}\n          >\n            {/* Header */}\n            <button\n              type=\"button\"\n              onClick={() => handleToggle(item, index)}\n              className={cn(\n                'lite-kit-accordion-header',\n                'w-full flex items-center gap-4 p-4 text-left cursor-pointer',\n                'transition-colors duration-200 active:scale-[0.99]'\n              )}\n              aria-expanded={isOpen}\n              aria-controls={`accordion-content-${item.id}`}\n            >\n              {/* Icon */}\n              {Icon && (\n                <div\n                  className={cn(\n                    'lite-kit-accordion-icon',\n                    'w-12 h-12 rounded-full flex-shrink-0 flex items-center justify-center',\n                    'transition-all duration-300',\n                    isOpen && 'lite-kit-accordion-icon--active'\n                  )}\n                >\n                  <Icon className=\"lite-kit-accordion-icon-svg w-6 h-6 transition-colors duration-300\" />\n                </div>\n              )}\n\n              {/* Title and subtitle */}\n              <div className=\"lite-kit-accordion-text flex-1 min-w-0\">\n                <h3 className=\"lite-kit-accordion-title text-sm font-medium\">\n                  {item.title}\n                </h3>\n                {item.subtitle && (\n                  <p\n                    className={cn(\n                      'lite-kit-accordion-subtitle text-sm mt-0.5 transition-colors duration-300',\n                      isOpen && 'lite-kit-accordion-subtitle--active'\n                    )}\n                  >\n                    {item.subtitle}\n                  </p>\n                )}\n              </div>\n\n              {/* Chevron in circle */}\n              <div\n                className={cn(\n                  'lite-kit-accordion-toggle',\n                  'w-6 h-6 rounded-full flex-shrink-0 flex items-center justify-center',\n                  'transition-all duration-300',\n                  isOpen && 'lite-kit-accordion-toggle--open'\n                )}\n              >\n                <ChevronIcon isOpen={isOpen} />\n              </div>\n            </button>\n\n            {/* Content */}\n            <div\n              id={`accordion-content-${item.id}`}\n              className={cn(\n                'lite-kit-accordion-content',\n                'overflow-hidden transition-all duration-300 ease-out',\n                isOpen\n                  ? 'lite-kit-accordion-content--open max-h-96 opacity-100'\n                  : 'lite-kit-accordion-content--closed max-h-0 opacity-0'\n              )}\n              role=\"region\"\n              aria-labelledby={`accordion-header-${item.id}`}\n            >\n              <div\n                className={cn(\n                  'lite-kit-accordion-content-inner leading-relaxed',\n                  Icon ? 'px-4 pb-4 pl-20' : 'px-4 pb-4'\n                )}\n              >\n                {typeof item.content === 'string' ? (\n                  <p>{item.content}</p>\n                ) : (\n                  item.content\n                )}\n              </div>\n            </div>\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n","/**\n * Utility function for merging class names\n * Filters out falsy values and joins remaining classes\n */\nexport function cn(...classes: (string | undefined | null | false)[]): string {\n  return classes.filter(Boolean).join(' ');\n}\n","import { useEffect, useRef, useState, useCallback, type RefObject } from 'react';\nimport type { ScrollConfig } from './types';\n\ninterface UseScrollDetectionProps {\n  /** Array of refs to track */\n  itemRefs: RefObject<(HTMLElement | null)[]>;\n  /** Number of items */\n  itemCount: number;\n  /** Whether scroll detection is enabled */\n  enabled: boolean;\n  /** Configuration options */\n  config?: ScrollConfig;\n  /** Callback when active item changes */\n  onActiveChange: (index: number | null) => void;\n  /** Currently active index (for hysteresis comparison) */\n  activeIndex: number | null;\n}\n\ninterface UseScrollDetectionReturn {\n  /** Call this when user manually interacts */\n  handleManualInteraction: (index: number) => void;\n  /** Whether manual interaction is active (temporarily disables scroll detection) */\n  isManuallySelected: boolean;\n  /** Index of manually closed item (won't auto-reopen) */\n  manuallyClosedIndex: number | null;\n  /** Clear manually closed state */\n  clearManuallyClosed: () => void;\n}\n\nexport function useScrollDetection({\n  itemRefs,\n  itemCount,\n  enabled,\n  config = {},\n  onActiveChange,\n  activeIndex,\n}: UseScrollDetectionProps): UseScrollDetectionReturn {\n  const { hysteresis = 0.3, scrollToCenter = true, mobileOnly = true } = config;\n\n  const [isManuallySelected, setIsManuallySelected] = useState(false);\n  const [manuallyClosedIndex, setManuallyClosedIndex] = useState<number | null>(null);\n  const [isMobile, setIsMobile] = useState(false);\n  const manualInteractionTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  // Detect mobile device\n  useEffect(() => {\n    const checkMobile = () => {\n      setIsMobile(window.innerWidth < 768);\n    };\n    checkMobile();\n    window.addEventListener('resize', checkMobile);\n    return () => window.removeEventListener('resize', checkMobile);\n  }, []);\n\n  // Determine if scroll detection should be active\n  const isScrollDetectionActive = enabled && (!mobileOnly || isMobile);\n\n  // Handle manual tap/click interaction\n  const handleManualInteraction = useCallback((index: number) => {\n    // Only apply scroll detection behaviour when active\n    if (!isScrollDetectionActive) return;\n\n    setIsManuallySelected(true);\n\n    // Scroll to centre if enabled\n    if (scrollToCenter && itemRefs.current) {\n      itemRefs.current[index]?.scrollIntoView({\n        behavior: 'smooth',\n        block: 'center',\n      });\n    }\n\n    // Clear any existing timeout\n    if (manualInteractionTimeoutRef.current) {\n      clearTimeout(manualInteractionTimeoutRef.current);\n    }\n\n    // Re-enable scroll detection after scroll completes\n    manualInteractionTimeoutRef.current = setTimeout(() => {\n      setIsManuallySelected(false);\n    }, 800);\n  }, [scrollToCenter, itemRefs, isScrollDetectionActive]);\n\n  // Mark an item as manually closed\n  const markAsManuallyClosed = useCallback((index: number) => {\n    setManuallyClosedIndex(index);\n  }, []);\n\n  // Clear manually closed state\n  const clearManuallyClosed = useCallback(() => {\n    setManuallyClosedIndex(null);\n  }, []);\n\n  // Scroll detection effect\n  useEffect(() => {\n    if (!isScrollDetectionActive) return;\n\n    const handleScroll = () => {\n      // Don't override during manual interaction\n      if (isManuallySelected) return;\n\n      const refs = itemRefs.current;\n      if (!refs) return;\n\n      const viewportHeight = window.innerHeight;\n      const viewportCenter = viewportHeight / 2;\n\n      // Find the item whose centre is closest to viewport centre\n      let closestIndex: number | null = null;\n      let closestDistance = Infinity;\n\n      for (let i = 0; i < itemCount; i++) {\n        const ref = refs[i];\n        if (!ref) continue;\n\n        const rect = ref.getBoundingClientRect();\n        const itemCenter = rect.top + rect.height / 2;\n        const distance = Math.abs(itemCenter - viewportCenter);\n\n        // Only consider items at least partially visible\n        if (rect.bottom > 0 && rect.top < viewportHeight) {\n          if (distance < closestDistance) {\n            closestDistance = distance;\n            closestIndex = i;\n          }\n        }\n      }\n\n      // Apply hysteresis to prevent jittery switching\n      if (closestIndex !== null && closestIndex !== activeIndex) {\n        if (activeIndex !== null && refs[activeIndex]) {\n          const currentRect = refs[activeIndex]!.getBoundingClientRect();\n          const currentDistance = Math.abs(\n            currentRect.top + currentRect.height / 2 - viewportCenter\n          );\n\n          // Only switch if new item is significantly closer\n          const threshold = 1 - hysteresis;\n          if (closestDistance >= currentDistance * threshold) {\n            return; // Current item is still close enough\n          }\n        }\n\n        // Clear manually closed state if scrolling to a different item\n        if (manuallyClosedIndex !== null && closestIndex !== manuallyClosedIndex) {\n          setManuallyClosedIndex(null);\n        }\n\n        // Only activate if not manually closed\n        if (closestIndex !== manuallyClosedIndex) {\n          onActiveChange(closestIndex);\n        }\n      }\n    };\n\n    window.addEventListener('scroll', handleScroll, { passive: true });\n    handleScroll(); // Initial check\n\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [\n    isScrollDetectionActive,\n    isManuallySelected,\n    itemRefs,\n    itemCount,\n    hysteresis,\n    activeIndex,\n    manuallyClosedIndex,\n    onActiveChange,\n  ]);\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (manualInteractionTimeoutRef.current) {\n        clearTimeout(manualInteractionTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    handleManualInteraction,\n    isManuallySelected,\n    manuallyClosedIndex,\n    clearManuallyClosed,\n  };\n}\n\n// Helper to set manually closed (exposed for component use)\nexport function useManualClose() {\n  const [manuallyClosedIndex, setManuallyClosedIndex] = useState<number | null>(null);\n\n  return {\n    manuallyClosedIndex,\n    setManuallyClosed: setManuallyClosedIndex,\n    clearManuallyClosed: () => setManuallyClosedIndex(null),\n  };\n}\n"],"mappings":"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","names":["import_react"]}